#!/usr/bin/env python


#   'node.py'
# 
#   Copyright (C) 2015 Jorge Couchet <jorge.couchet at gmail.com>
#
#   This file is part of 'ros_key_auth'
# 
#   'ros_key_auth' is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
# 
#   'ros_key_auth' is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
# 
#   You should have received a copy of the GNU General Public License
#   along with 'ros_key_auth'.  If not, see <http ://www.gnu.org/licenses/>.
#


# Import the needed ROS libraries
import roslib
import rospy

# Import the custom messages
from key_auth.msg import Auth1Msg, Auth2Msg, Status

import sys, os

# Used to read and write csv files
import csv

# The name of the users database
DBFILE = "db_file.csv"


# The main class for the current ROS node
class KeyAuth:

   def __init__(self, name):

      # Save node name
      self.name = name 

      # Load the user database
      self.load_usr_db()

      # Create subscriber for keyboard dynamics
      # generated by the user (Auth2Msg)
      rospy.Subscriber(  "key_auth_keydyn"
                       , Auth2Msg
                       , self.callback_classify
                       , queue_size = 1)

      # Create publisher for the status message (if the
      # user is authenticated or not)
      self.pub_sts = rospy.Publisher(  "key_auth_stat"
                                     , Status
                                     , queue_size = 1)

   # The callback associated with the subscriber for
   # the keyboard dynamics
   #
   # "msg" has the type Auth2Msg
   #
   # It is implementing authentication by the user
   # keyboard dynamics
   def callback_classify(self, msg):
  
      # Create a Status msg
      sts = Status()

      # Retrieving the message payload 
      usr = msg.mail
      mail_akl = msg.akls[0]
      txt1_akl = msg.akls[1]
      txt2_akl = msg.akls[2]

      current_usr = {"mail": usr, "mail_akl": mail_akl, "txt1_akl": txt1_akl, "txt2_akl": txt2_akl}

      rospy.loginfo("Processing authentication for user: " + usr)

      if usr in self.db:
      
         # Find the distance between the different key latencies
         dist1 = abs(float(self.db[usr]["mail_akl"]) - float(self.db[usr]["txt1_akl"]))
         dist2 = abs(float(self.db[usr]["mail_akl"]) - float(self.db[usr]["txt2_akl"]))
         dist3 = abs(float(self.db[usr]["txt1_akl"]) - float(self.db[usr]["txt2_akl"]))

         # Find the maximum distance between the different key latencies
         max_dist = max(dist1, dist2, dist3)

         # Find the distances between the new key latencies and the holded
         # in the database
         dist1 = abs(float(self.db[usr]["mail_akl"]) - mail_akl)
         dist2 = abs(float(self.db[usr]["txt1_akl"]) - txt1_akl)
         dist3 = abs(float(self.db[usr]["txt2_akl"]) - txt2_akl)

         # Compare these distances with the maximum distance
         if (dist1 <= max_dist) and (dist2 <= max_dist) and (dist3 <= max_dist):
            sts.ok = True

            # Update the latencies in the database in order to adapt to the user changes
            current_usr["mail_akl"] = (float(self.db[usr]["mail_akl"]) + mail_akl)/2
            current_usr["txt1_akl"] = (float(self.db[usr]["txt1_akl"]) + txt1_akl)/2
            current_usr["txt2_akl"] = (float(self.db[usr]["txt2_akl"]) + txt2_akl)/2

            self.update_usr_db(current_usr)

         else:
            sts.ok = False

      else:
         # It is a new user
         self.add_usr_db(current_usr)      

         sts.ok = True

      # Publish the authentication result in the Status message
      self.pub_sts.publish(sts)

   # Load the users database
   def load_usr_db(self):

      self.db = {}

      try:
         fp = open(os.path.dirname(sys.argv[0]) + "/" + DBFILE, "a+")

         csvf = csv.DictReader(fp, fieldnames=["mail", "mail_akl", "txt1_akl", "txt2_akl"], delimiter=',', quotechar='"')

         for line in csvf:
            # The entries are indexed by the user identifier (user mail)
            self.db[line["mail"]] = line

         fp.close()

      except Exception as e:
         raise      

   # Add a new user to the database (add in the online and the file db)
   def add_usr_db(self,usr):

      self.db[usr["mail"]] = usr

      try:
         fp = open(os.path.dirname(sys.argv[0]) + "/" + DBFILE, "a")

         csvf = csv.DictWriter(fp, fieldnames=["mail", "mail_akl", "txt1_akl", "txt2_akl"], delimiter=',', quotechar='"')

         csvf.writerow(usr)

         fp.close
      except Exception as e:
         raise


   # Add the user info in the database (update the online and the file db)
   def update_usr_db(self,usr):

      self.db[usr["mail"]] = usr

      try:
         # Replace the existing file
         fp = open(os.path.dirname(sys.argv[0]) + "/" + DBFILE, "w")

         csvf = csv.DictWriter(fp, fieldnames=["mail", "mail_akl", "txt1_akl", "txt2_akl"], delimiter=',', quotechar='"')

         for dbusr in (self.db).keys():
            csvf.writerow(self.db[dbusr])

         fp.close
      except Exception as e:
         raise 
      


if __name__ == "__main__":

   try:
      # Init the current ROS node
      rospy.init_node("key_auth", anonymous=True)

      try:
         # Instatiate the main node class, because it
         # is the one that start all the node work
         KA = KeyAuth(rospy.get_name())
      except Exception as e:
         rospy.signal_shutdown("It was not possible to instantiate the main class")

      # It is creating a thread where the node
      # is living until killed
      rospy.spin()
   except rospy.ROSInterruptException:
      pass
